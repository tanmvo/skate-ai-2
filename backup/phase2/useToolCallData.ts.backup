import { useMemo } from 'react';
import { ToolCallEvent, ToolCallData, ChatStreamData } from '@/lib/types/chat-phases';

/**
 * Hook to extract and process tool call events from the useChat data stream
 */
export function useToolCallData(dataStream: unknown[] | undefined, messageId: string): ToolCallData {
  return useMemo(() => {
    // Enhanced type safety: handle undefined, null, and non-array data
    if (!dataStream || !Array.isArray(dataStream) || dataStream.length === 0) {
      return {
        messageId,
        events: [],
        isActive: false,
        lastActivity: 0,
      };
    }

    // Filter for tool call events with enhanced type safety
    const toolCallEvents = dataStream
      .filter((item): item is ChatStreamData => {
        // Comprehensive type checking to prevent runtime errors
        try {
          return (
            typeof item === 'object' &&
            item !== null &&
            'type' in item &&
            typeof (item as Record<string, unknown>).type === 'string' &&
            ((item as Record<string, unknown>).type === 'tool-call-start' || (item as Record<string, unknown>).type === 'tool-call-end')
          );
        } catch (error) {
          // Gracefully handle any unexpected errors in type checking
          console.warn('Error filtering tool call events:', error);
          return false;
        }
      })
      .map((item): ToolCallEvent => {
        // Safe mapping with fallback values
        try {
          return {
            type: item.type as 'tool-call-start' | 'tool-call-end',
            toolName: typeof item.toolName === 'string' ? item.toolName : '',
            parameters: item.parameters || {},
            result: typeof item.result === 'string' ? item.result : undefined,
            timestamp: typeof item.timestamp === 'number' ? item.timestamp : Date.now(),
            success: typeof item.success === 'boolean' ? item.success : undefined,
          };
        } catch (error) {
          console.warn('Error mapping tool call event:', error, item);
          return {
            type: 'tool-call-end', // Safe fallback
            toolName: 'unknown',
            parameters: {},
            result: undefined,
            timestamp: Date.now(),
            success: false,
          };
        }
      })
      .sort((a, b) => a.timestamp - b.timestamp);

    // Determine if any tools are currently active
    const toolStates = new Map<string, boolean>();
    toolCallEvents.forEach(event => {
      if (event.type === 'tool-call-start') {
        toolStates.set(event.toolName, true);
      } else if (event.type === 'tool-call-end') {
        toolStates.set(event.toolName, false);
      }
    });

    const isActive = Array.from(toolStates.values()).some(active => active);
    const lastActivity = toolCallEvents.length > 0 
      ? Math.max(...toolCallEvents.map(e => e.timestamp))
      : 0;

    return {
      messageId,
      events: toolCallEvents,
      isActive,
      lastActivity,
    };
  }, [dataStream, messageId]);
}

/**
 * Generate user-friendly display text for tool calls
 */
export function generateThinkingText(toolCallEvents: ToolCallEvent[]): string {
  if (toolCallEvents.length === 0) {
    return 'Processing your request...';
  }

  // Get the most recent active tool or the last completed tool
  const activeTools = toolCallEvents
    .filter(event => event.type === 'tool-call-start')
    .map(event => event.toolName);

  const completedTools = new Set(
    toolCallEvents
      .filter(event => event.type === 'tool-call-end')
      .map(event => event.toolName)
  );

  // Find currently active tools
  const currentlyActive = activeTools.filter(tool => !completedTools.has(tool));
  
  if (currentlyActive.length > 0) {
    const toolName = currentlyActive[currentlyActive.length - 1];
    return getToolDisplayText(toolName, true);
  }

  // If no active tools, show the last completed tool
  if (activeTools.length > 0) {
    const lastTool = activeTools[activeTools.length - 1];
    return getToolDisplayText(lastTool, false);
  }

  return 'Processing your request...';
}

/**
 * Get display text for specific tool names
 */
function getToolDisplayText(toolName: string, isActive: boolean): string {
  const activeText = isActive ? '...' : '';
  
  switch (toolName) {
    case 'find_document_ids':
      return `Looking up documents${activeText}`;
    case 'search_specific_documents':
      return `Searching specific documents${activeText}`;
    case 'search_all_documents':
      return `Searching all documents${activeText}`;
    default:
      return `Processing${activeText}`;
  }
}

/**
 * Check if there are any active tool calls
 */
export function hasActiveToolCalls(toolCallData: ToolCallData): boolean {
  return toolCallData.isActive;
}

/**
 * Get a summary of completed tool calls for display
 */
export function getToolCallSummary(toolCallEvents: ToolCallEvent[]): string[] {
  const completedTools = toolCallEvents
    .filter(event => event.type === 'tool-call-end' && event.success)
    .map(event => event.toolName);

  const uniqueTools = [...new Set(completedTools)];
  
  return uniqueTools.map(toolName => {
    switch (toolName) {
      case 'find_document_ids':
        return 'Found document IDs';
      case 'search_specific_documents':
        return 'Searched specific documents';
      case 'search_all_documents':
        return 'Searched all documents';
      default:
        return 'Completed processing';
    }
  });
}